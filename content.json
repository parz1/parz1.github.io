{"pages":[],"posts":[{"title":"Initial hexo","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/05/hello-world/"},{"title":"Cohen-Sutherland 线段裁剪算法","text":"双十一没什么好买的，来写博客了。 裁剪算法：一般情况下用来消除制定区域内或区域外的图形部分的过程叫裁剪。二维裁剪算法有：点/线段/区域/曲线/文字的裁剪，此文介绍Cohen-Sutherland线段裁剪算法。 clear all; n = 100;Xmin = -4; Xmax = 4;Ymin = -3; Ymax = 3; figure; hold on; P1x = rand(1,n)20 - 10;P2x = rand(1,n)20 - 10;P1y = rand(1,n)20 - 10;P2y = rand(1,n)20 - 10;P1code = zeros(n,4);P2code = zeros(n,4); for i = 1:n if P1x(i) &lt; Xmin P1code(i,1) = 1; end if P1x(i) &gt; Xmax P1code(i,2) = 1; end if P1y(i) &lt; Ymin P1code(i,3) = 1; end if P1y(i) &gt; Ymax P1code(i,4) = 1; end if P2x(i) &lt; Xmin P2code(i,1) = 1; end if P2x(i) &gt; Xmax P2code(i,2) = 1; end if P2y(i) &lt; Ymin P2code(i,3) = 1; end if P2y(i) &gt; Ymax P2code(i,4) = 1; end plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],&apos;b-&apos;);endhold off; P_label = zeros(1,n);figure; hold on;for i = 1:n P_or = P1code(i,1:4) | P2code(i,1:4); if sum(P_or) == 0 P_label(i) = 1; plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],’r-‘); end P_and = P1code(i,1:4) &amp; P2code(i,1:4); if sum(P_and) &gt; 0 P_label(i) = 2; plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],’g-‘); endendhold off; figure; hold on;for i = 1:n if P_label(i) == 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 P_or = P1code(i,1:4) | P2code(i,1:4); plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],'g-'); if P_or(1) == 1 Py = P1y(i) + (Xmin-P1x(i))*(P2y(i)-P1y(i))/(P2x(i)-P1x(i)); if P1x(i) &lt; Xmin P1x(i) = Xmin; P1y(i) = Py; elseif P2x(i) &lt; Xmin P2x(i) = Xmin; P2y(i) = Py; end end if P_or(2) == 1 Py = P1y(i) + (Xmax-P1x(i))*(P2y(i)-P1y(i))/(P2x(i)-P1x(i)); if P1x(i) &gt; Xmax P1x(i) = Xmax; P1y(i) = Py; elseif P2x(i) &gt; Xmax P2x(i) = Xmax; P2y(i) = Py; end end if P_or(3) == 1 Px = P1x(i) + (Ymin-P1y(i))/(P2y(i)-P1y(i))*(P2x(i)-P1x(i)); if P1y(i) &lt; Ymin P1x(i) = Px; P1y(i) = Ymin; elseif P2y(i) &lt; Ymin P2x(i) = Px; P2y(i) = Ymin; end end if P_or(4) == 1 Px = P1x(i) + (Ymax-P1y(i))/(P2y(i)-P1y(i))*(P2x(i)-P1x(i)); if P1y(i) &gt; Ymax P1x(i) = Px; P1y(i) = Ymax; elseif P2y(i) &gt; Ymax P2x(i) = Px; P2y(i) = Ymax; end end if P1x(i) &gt;= Xmin &amp; P1x(i) &lt;= Xmax &amp; ... P2x(i) &gt;= Xmin &amp; P2x(i) &lt;= Xmax &amp; ... P1y(i) &gt;= Ymin &amp; P1y(i) &lt;= Ymax &amp; ... P2y(i) &gt;= Ymin &amp; P2y(i) &lt;= Ymax plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],'m-','LineWidth',2); end plot([-4 4 4 -4 -4],[-3 -3 3 3 -3],'b-','LineWidth',2);end","link":"/2019/11/11/grapics-clipping/"},{"title":"SFML引入shader/Import shaders(SFML)","text":"既然学了sfml这种歪门邪道的东西，就试试里面的shader 说实在并不是很清楚shader的GLSL语法是怎么写的，但是既然是类C语言，就不怕读不了源码，于是去google找了相关资料 sf::Shader首先还是sfml对于引入shader的官方文档： In SFML, shaders are represented by the sf::Shader class. It handles both the vertex and fragment shaders: A sf::Shader object is a combination of both (or only one, if the other is not provided). 意思是 sfml 中也有两种shader类即顶点着色器和片元着色器 shader要结合两者进行 12345if (!sf::Shader::isAvailable()){ // 检验shader是否有效 // shaders are not available...} 对sf::Shader的使用如下： 12345678910111213141516171819sf::Shader shader;// load only the vertex shaderif (!shader.loadFromFile(\"vertex_shader.vert\", sf::Shader::Vertex)){ // error...}// load only the fragment shaderif (!shader.loadFromFile(\"fragment_shader.frag\", sf::Shader::Fragment)){ // error...}// load both shadersif (!shader.loadFromFile(\"vertex_shader.vert\", \"fragment_shader.frag\")){ // error...} 而对于shader源文件，文档解释如下： Shaders can also be loaded directly from strings, with the loadFromMemory function. This can be useful if you want to embed the shader source directly into your program. 即shader可由string和文件引入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const std::string vertexShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";const std::string fragmentShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";// load only the vertex shaderif (!shader.loadFromMemory(vertexShader, sf::Shader::Vertex)){ // error...}// load only the fragment shaderif (!shader.loadFromMemory(fragmentShader, sf::Shader::Fragment)){ // error...}// load both shadersif (!shader.loadFromMemory(vertexShader, fragmentShader)){ // error...}const std::string vertexShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";const std::string fragmentShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";// load only the vertex shaderif (!shader.loadFromMemory(vertexShader, sf::Shader::Vertex)){ // error...}// load only the fragment shaderif (!shader.loadFromMemory(fragmentShader, sf::Shader::Fragment)){ // error...}// load both shadersif (!shader.loadFromMemory(vertexShader, fragmentShader)){ // error...} Shader.vert/.frag后缀名其实无所谓，源于文档解释 Shader source is contained in simple text files (like your C++ code). Their extension doesn’t really matter, it can be anything you want, you can even omit it. “.vert” and “.frag” are just examples of possible extensions. 给出水波纹shader的源码： shader.frag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#version 130#水波纹shaderuniform sampler2D currentTexture; // Our render textureuniform sampler2D distortionMapTexture; // Our heat distortion map textureuniform float time; // Time used to scroll the distortion mapuniform float distortionFactor; // Factor used to control severity of the effectuniform float riseFactor; // Factor used to control how fast air risesvoid main(){ vec2 distortionMapCoordinate = gl_TexCoord[0].st; // We use the time value to scroll our distortion texture upwards // Since we enabled texture repeating, OpenGL takes care of // coordinates that lie outside of [0, 1] by discarding // the integer part and keeping the fractional part // Basically performing a \"floating point modulo 1\" // 1.1 = 0.1, 2.4 = 0.4, 10.3 = 0.3 etc. distortionMapCoordinate.t -= time * riseFactor; vec4 distortionMapValue = texture2D(distortionMapTexture, distortionMapCoordinate); // The values are normalized by OpenGL to lie in the range [0, 1] // We want negative offsets too, so we subtract 0.5 and multiply by 2 // We end up with values in the range [-1, 1] vec2 distortionPositionOffset = distortionMapValue.xy; distortionPositionOffset -= vec2(0.5f, 0.5f); distortionPositionOffset *= 2.f; // The factor scales the offset and thus controls the severity distortionPositionOffset *= distortionFactor; // The latter 2 channels of the texture are unused... be creative vec2 distortionUnused = distortionMapValue.zw; // Since we all know that hot air rises and cools, // the effect loses its severity the higher up we get // We use the t (a.k.a. y) texture coordinate of the original texture // to tell us how \"high up\" we are and damp accordingly // Remember, OpenGL 0 is at the bottom distortionPositionOffset *= (1.f - gl_TexCoord[0].t); vec2 distortedTextureCoordinate = gl_TexCoord[0].st + distortionPositionOffset; gl_FragColor = gl_Color * texture2D(currentTexture, distortedTextureCoordinate);} SFML_Shader.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/*! * \\file main.cpp * \\brief apply a heat shader to a sprite (http://www.lucidarme.me/?p=6127) * \\author Philippe Lucidarme (from https://github.com/SFML/SFML/wiki/Source:-HeatHazeShader) * \\version 1.0 * \\date 12/19/2016 */#include &quot;pch.h&quot; // SFML libraries#include &lt;SFML/Graphics.hpp&gt;#include &lt;SFML/System.hpp&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;int main(){ // _____________________ // ::: Create window ::: // Create a window with the same pixel depth as the desktop sf::VideoMode desktopMode = sf::VideoMode::getDesktopMode(); sf::RenderWindow window(sf::VideoMode(desktopMode.width, desktopMode.height, desktopMode.bitsPerPixel), &quot;SFML part 5&quot;);// ,sf::Style::Fullscreen); // Enable vertical sync. (vsync) //window.setVerticalSyncEnabled(true); // ____________________ // ::: Load texture ::: // Create texture from PNG file sf::Texture texture; if (!texture.loadFromFile(&quot;sfml_icon_small.png&quot;)) { std::cerr &lt;&lt; &quot;Error while loading texture&quot; &lt;&lt; std::endl; return -1; } // Enable the smooth filter. The texture appears smoother so that pixels are less noticeable. texture.setSmooth(true); // _______________________________________ // ::: Create sprite and apply texture ::: // Create the sprite and apply the texture sf::Sprite sprite; sprite.setTexture(texture); sf::FloatRect spriteSize = sprite.getGlobalBounds(); // Set origin in the middle of the sprite sprite.setOrigin(spriteSize.width / 2., spriteSize.height / 2.); // _______________ // ::: Shaders ::: // Check if shaders are available if (!sf::Shader::isAvailable()) { std::cerr &lt;&lt; &quot;Shader are not available&quot; &lt;&lt; std::endl; return -1; } // Load shaders sf::Shader shader; if (!shader.loadFromFile(&quot;shader.frag&quot;, sf::Shader::Fragment)) { std::cerr &lt;&lt; &quot;Error while shaders&quot; &lt;&lt; std::endl; return -1; } // ___________________________ // ::: Load distortion map ::: sf::Texture distortionMap; if (!distortionMap.loadFromFile(&quot;distortion_map.png&quot;)) { sf::err() &lt;&lt; &quot;Error while loading distortion map&quot; &lt;&lt; std::endl; return -1; } // It is important to set repeated to true to enable scrolling upwards distortionMap.setRepeated(true); // Setting smooth to true lets us use small maps even on larger images distortionMap.setSmooth(true); // Set texture to the shader shader.setParameter(&quot;currentTexture&quot;, sf::Shader::CurrentTexture); shader.setParameter(&quot;distortionMapTexture&quot;, distortionMap); // Shader parameters float distortionFactor = .05f; float riseFactor = .2f; // _________________ // ::: Main loop ::: sf::Clock timer; while (window.isOpen()) { // Process events sf::Event event; while (window.pollEvent(event)) { // Close the window if a key is pressed or if requested if (event.type == sf::Event::Closed) window.close(); // If a key is pressed if (event.type == sf::Event::KeyPressed) { switch (event.key.code) { // If escape is pressed, close the application case sf::Keyboard::Escape: window.close(); break; // Process the up, down, left and right keys to modify parameters case sf::Keyboard::Up: distortionFactor *= 2.f; break; case sf::Keyboard::Down: distortionFactor /= 2.f; break; case sf::Keyboard::Left: riseFactor *= 2.f; break; case sf::Keyboard::Right: riseFactor /= 2.f; break; default: break; } } } // Set shader parameters shader.setParameter(&quot;time&quot;, timer.getElapsedTime().asSeconds()); shader.setParameter(&quot;distortionFactor&quot;, distortionFactor); shader.setParameter(&quot;riseFactor&quot;, riseFactor); // Clear the window and apply grey background window.clear(sf::Color(127, 127, 127)); // Draw the sprite and apply shader sprite.setPosition(window.getSize().x / 2., window.getSize().y / 2.); sprite.setScale(2, 2); window.draw(sprite, &amp;shader); // Update display and wait for vsync window.display(); } return 0;} 最终效果图 参考链接 sfml官方教程/文档 国外某大神sfml教程","link":"/2019/11/10/sfml_shader/"}],"tags":[{"name":"ComputerGrapics","slug":"ComputerGrapics","link":"/tags/ComputerGrapics/"},{"name":"二维观察","slug":"二维观察","link":"/tags/%E4%BA%8C%E7%BB%B4%E8%A7%82%E5%AF%9F/"},{"name":"裁剪算法","slug":"裁剪算法","link":"/tags/%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95/"},{"name":"sfml","slug":"sfml","link":"/tags/sfml/"}],"categories":[{"name":"game&graphics","slug":"game-graphics","link":"/categories/game-graphics/"}]}
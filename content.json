{"pages":[],"posts":[{"title":"前端各种分辨率测试工具Resolution Test","text":"前端分辨率测试工具，你值得拥有。 Resolution Test 使用方法非常简单，添加到插件里点击它即可。 官网 如果你有更好的方法和工具，欢迎评论或给我发邮件 :)","link":"/2019/11/14/fe-screen/"},{"title":"Discord下载/使用/修改Hosts","text":"Discord类似国内YY，不过软件不是一个层次。 本文分享discod的下载和修改hosts 本文已废，请使用代理方式，改Hosts方式接下来都不会再有用 首先附上discord的下载地址 Discord 注册地址（需科学上网） 修改host要用到UsbEAm Hosts Editor 本文提供一个链接，自行前往下载： UsbEAm Hosts Editor v3.50 打开效果如下，点击编辑hosts 在文件最后添加如下文本 123456789101112# Discord Start104.16.248.114 dl.discordapp.net104.16.60.37 gateway.discord.gg104.16.11.231 status.discordapp.com104.16.9.231 cdn.discordapp.com104.16.59.5 discordapp.com104.16.250.144 media.discordapp.net104.16.249.144 images-ext-2.discordapp.net104.16.250.144 images-ext-1.discordapp.net151.101.78.214 static-cdn.jtvnw.net# Discord End127.0.0.1 activate.navicat.com127.0.0.1 activate.navicat.com 然后就不用科学上网即可运行discord，注册登录 欢迎来我频道一起玩 https://discord.gg/HyrRPtR 我的Discord标签：parz1#7093","link":"/2020/01/19/discord-usage/"},{"title":"C#特性Attribute Usage小试","text":"学到System.IO还好，挺简单，到这突然给我来了一巴掌似的。 还是得好好研究下。 在unity当中有[range(0,1)]这样的方法来限制变量范围 Conditional这个预定义特性标记了一个条件方法，其执行依赖于指定的预处理标识符。 123[Conditional( conditionalSymbol)] 需要注意的是此特性需要System.Diagnostics命名空间 1234567891011121314151617#define DEBUGusing System;using System.Diagnostics;public class Myclass{ [Conditional(\"DEBUG\")] public static void Message(string msg) { Console.WriteLine(msg); }}class Test{ public static void Main() { Myclass.Message(\"In Main function.\"); }} 若在上述代码将#define DEBUG去掉，Message就不会编译和执行，可以用来调试时打印过程等 Obsolete这个预定义特性标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。 1234[Obsolete( message, iserror)] 12345[Obsolete(&quot;Don&apos;t use OldMethod, use NewMethod instead&quot;, true)] static void OldMethod() { Console.WriteLine(&quot;It is the old method&quot;); } 然后在Main函数里调用OldMethod便会编译器报错：Don’t use …. ，总之，我目前觉得没啥用，可能重构/项目重写的时候会用到。 构建自定义特性预定义特性 AttributeUsage 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。 123456789101112131415161718192021222324252627282930313233343536[AttributeUsage( validon, AllowMultiple=allowmultiple, Inherited=inherited)]//用法如下[AttributeUsage(AttributeTargets.All)]public class TestAttribute : Attribute{}[TestAttribute]//结构public struct TestStruct { }[TestAttribute]//枚举public enum TestEnum { }[TestAttribute]//类上public class TestClass{ [TestAttribute] public TestClass() { } [TestAttribute]//字段 private string _testField; [TestAttribute]//属性 public string TestProperty { get; set; } [TestAttribute]//方法上 [return: TestAttribute]//定义返回值的写法 public string TestMethod([TestAttribute] string testParam)//参数上 { throw new NotImplementedException(); }} validon 枚举AttributeTargets的值 default 为 AttributeTargets.all AllowMultipie 布尔值：特性是否多用 inherited 布尔值：是否可继承 1234567891011121314151617181920[AttributeUsage(AttributeTargets.Property)] class ValidAttribute : Attribute { public ValidAttribute(int maxLength) { _maxLength = maxLength; } private int _maxLength; protected int MaxLength //这里的get和set和vue里getter setter很像 { get { return _maxLength; } set { _maxLength = value; } } } 自定义一个Attribute类检查字符串长度 写一个实体类使用自定义特性 12345class BaseClass { [Valid(10)] public String Name { get; set; } } 写一个验证类 1234567891011121314151617181920212223class Valid{ public void Validate(object obj) { var t = obj.GetType(); var properties = t.GetProperties(); foreach (var property in properties) { if (!property.IsDefined(typeof(ValidAttribute), false)) continue; var attributes = property.GetCustomAttributes(false); foreach (var attribute in attributes) { var maxLength = (int)attribute.GetType().GetProperty(\"MaxLength\").GetValue(attribute); var propertyValue = property.GetValue(obj) as string; if (propertyValue == null) throw new Exception(\"value is null.\"); if (propertyValue.Length &gt; maxLength) throw new Exception(string.Format(\"属性{0}的值{1}超过了限制长度{2}\", property.Name, propertyValue, maxLength)); } } }} 最后主函数运行 123456789101112131415static void Main(string[] args) { var Account = new Account() { Name = \"Parz1\", Pwd = \"123\" }; try { ValidFunc vf = new ValidFunc(); vf.Validate(Account); Console.WriteLine(vf); } catch (Exception ex) { Console.WriteLine(ex.Message); } Console.ReadLine(); } 测试结果 1属性Name的值Parz112超过了限制长度5 总结学着别人写下来感觉特性配合反射可以做很多事，现在只了解了这么一种写法，其它的以后有时间再跟进。","link":"/2020/01/30/CSharp-Attribute/"},{"title":"Cohen-Sutherland 线段裁剪算法","text":"双十一没什么好买的，来写博客了。 裁剪算法：一般情况下用来消除制定区域内或区域外的图形部分的过程叫裁剪。二维裁剪算法有：点/线段/区域/曲线/文字的裁剪，此文介绍Cohen-Sutherland线段裁剪算法。 clear all; n = 100;Xmin = -4; Xmax = 4;Ymin = -3; Ymax = 3; figure; hold on; P1x = rand(1,n)20 - 10;P2x = rand(1,n)20 - 10;P1y = rand(1,n)20 - 10;P2y = rand(1,n)20 - 10;P1code = zeros(n,4);P2code = zeros(n,4); for i = 1:n if P1x(i) &lt; Xmin P1code(i,1) = 1; end if P1x(i) &gt; Xmax P1code(i,2) = 1; end if P1y(i) &lt; Ymin P1code(i,3) = 1; end if P1y(i) &gt; Ymax P1code(i,4) = 1; end if P2x(i) &lt; Xmin P2code(i,1) = 1; end if P2x(i) &gt; Xmax P2code(i,2) = 1; end if P2y(i) &lt; Ymin P2code(i,3) = 1; end if P2y(i) &gt; Ymax P2code(i,4) = 1; end plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],&apos;b-&apos;);endhold off; P_label = zeros(1,n);figure; hold on;for i = 1:n P_or = P1code(i,1:4) | P2code(i,1:4); if sum(P_or) == 0 P_label(i) = 1; plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],’r-‘); end P_and = P1code(i,1:4) &amp; P2code(i,1:4); if sum(P_and) &gt; 0 P_label(i) = 2; plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],’g-‘); endendhold off; figure; hold on;for i = 1:n if P_label(i) == 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 P_or = P1code(i,1:4) | P2code(i,1:4); plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],'g-'); if P_or(1) == 1 Py = P1y(i) + (Xmin-P1x(i))*(P2y(i)-P1y(i))/(P2x(i)-P1x(i)); if P1x(i) &lt; Xmin P1x(i) = Xmin; P1y(i) = Py; elseif P2x(i) &lt; Xmin P2x(i) = Xmin; P2y(i) = Py; end end if P_or(2) == 1 Py = P1y(i) + (Xmax-P1x(i))*(P2y(i)-P1y(i))/(P2x(i)-P1x(i)); if P1x(i) &gt; Xmax P1x(i) = Xmax; P1y(i) = Py; elseif P2x(i) &gt; Xmax P2x(i) = Xmax; P2y(i) = Py; end end if P_or(3) == 1 Px = P1x(i) + (Ymin-P1y(i))/(P2y(i)-P1y(i))*(P2x(i)-P1x(i)); if P1y(i) &lt; Ymin P1x(i) = Px; P1y(i) = Ymin; elseif P2y(i) &lt; Ymin P2x(i) = Px; P2y(i) = Ymin; end end if P_or(4) == 1 Px = P1x(i) + (Ymax-P1y(i))/(P2y(i)-P1y(i))*(P2x(i)-P1x(i)); if P1y(i) &gt; Ymax P1x(i) = Px; P1y(i) = Ymax; elseif P2y(i) &gt; Ymax P2x(i) = Px; P2y(i) = Ymax; end end if P1x(i) &gt;= Xmin &amp; P1x(i) &lt;= Xmax &amp; ... P2x(i) &gt;= Xmin &amp; P2x(i) &lt;= Xmax &amp; ... P1y(i) &gt;= Ymin &amp; P1y(i) &lt;= Ymax &amp; ... P2y(i) &gt;= Ymin &amp; P2y(i) &lt;= Ymax plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],'m-','LineWidth',2); end plot([-4 4 4 -4 -4],[-3 -3 3 3 -3],'b-','LineWidth',2);end","link":"/2019/11/11/grapics-clipping/"},{"title":"基于类型题库的考试培训系统","text":"DEMO地址微信端：http://exam.parz1.com:8082/ 手机验证码登陆测试 管理端：http://parz1.com/ 测试账号：test 密码：test 2020/7/8后关闭测试 产品背景对于目前泛滥的问卷系统/考试系统，大多数都是基于临时编写的题目和题目库。而在对于某些工作人员进行培训和考核时，题目都是定死切分好模块的，所以各个单位都会有自己的一套线上考核系统，比如每个学校会用不同的线上考试系统。 此系统针对类似场景，建立有标签的题库系统和试卷生成模块，使管理题库和考试培训变得清晰有条理。 技术框架 功能分块 技术解释vue.js - 前端工程化 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。使用vue.js来实现前端工程化，包括组件化和数据驱动。模块化带来的代码低耦合高内聚效果是个人开发项目必备的。这为代码维护更新和后期团队的加入提供了坚实的基础。 vuetify - material design Vuetify 是一个 Vue UI 库，包含手工制作的精美材料组件。不需要设计技能 - 创建令人惊叹的应用程序所需的一切都触手可及。没有UI设计师，便发挥谷歌的material design优势，随便排版就能做出简洁好看的页面，vuetify在css的封装和组件自定义方面做的十分优秀。并且可以利用vuetify的sass断点轻松实现网页色调主题的切换。它还有一个优势是社区非常活跃，更新非常频繁。 PWA - Progressive Web App 谷歌推出的渐进式网页应用（pwa）。PWA是Progressive Web App的英文缩写， 翻译过来就是渐进式增强WEB应用， 是Google 在2016年提出的概念，2017年落地的web技术。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。 12345Reliable - Load instantly and never show the downasaur, even in uncertain network conditions.Fast - Respond quickly to user interactions with silky smooth animations and no janky scrolling.Engaging - Feel like a natural app on the device, with an immersive user experience. 可靠——即时加载，即使在不确定的网络条件下也不会受到影响。 快速 沉浸式体验—— 感觉就像设备上的原生应用程序，具有沉浸式的用户体验。 核心功能 Web App Manifest Service Worker Cache API 缓存 Push&amp;Notification 推送与通知 Background Sync 后台同步 响应式设计 优势： 无需安装，无需下载，只要你输入网址访问一次，然后将其添加到设备桌面就可以持续使用。 发布不需要提交到app商店审核 更新迭代版本不需要审核，不需要重新发布审核 现有的web网页都能通过改进成为PWA， 能很快的转型，上线，实现业务、获取流量 不需要开发Android和IOS两套不同的版本 劣势： 浏览器对技术支持还不够全面， 不是每一款浏览器都能100%的支持所有PWA 需要通过第三方库才能调用底层硬件（如摄像头） PWA现在还没那么火，国内一些手机生产上在Android系统上屏蔽了PWA node.js - 快速建站 利用node的express快速建站，能够立刻做出想要的效果，缺点是不够稳定，但生态还算完整。后期可能换GO。Express 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。 fly.js/axios.js - 前后端交互基础 使用了fly.js是考虑了微信访问的兼容性，两者用法基本一致，虽然作者强调实现不一致。Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 antv/f2 antv/g2plot 开箱即用的可视化图表 个人认为移动端适配最好的图表，蚂蚁金服可视化系列都很好用。 重点技术实现/展望人脸识别/文字识别/短信机 使用百度智慧云，后台nodejs-sdk实现人脸识别/文字识别。使用腾讯云短信机，发送模板短信。核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738//文字识别router.post(\"/uploadIdCard\", upload.single(\"idCard\"), (req, res, next) =&gt; { let file = req.file; var image = fs .readFileSync(\"uploads/idCard/\" + file.filename) .toString(\"base64\"); var idCardSide = \"front\"; client .idcard(image, idCardSide) .then(function (result) { console.log(JSON.stringify(result)); res.json({ status: \"success\", data: result.words_result, }); }) .catch(function (err) { // 如果发生网络错误 console.log(err); });});//短信机ssender.sendWithParam( 86, phoneNumbers[0], templateId, params, smsSign, //签名 \"\", \"\", (err, result, resData) =&gt; { res.json({ //返回response status: \"success\", data: resData, }); } 根据权重生成试卷 根据试卷难度设置，在相应题库里写一个算法，使得生成的题目序列尽可能接近对应的难度。这里用贪心算法就行。 这里node取题目使用到了Promise.all, 由于JS是异步单线程，取题目按题型又分成了不同块，如果使用同步则会大幅度增加抓题速度，于是使用Promise将不同块的异步进行，等最后一个异步完成返回数据，即可实现取题的加速。 防止爬虫 首先实现token是基本，再是限制接口调用次数。 前端埋点，爬虫不会渲染HTML和运行网页的js，通过前端埋点可以过滤掉中级的爬虫。 后台维护ip表，捕获封禁可疑ip。 网页加密/js加密，使用js打乱网页隐藏区域，使得爬虫返回乱码。 微信浏览器白条实现了history栈来存历史纪录，并使用replace把微信浏览器下方的白条去掉了，使得微信浏览器的使用体验更接近app","link":"/2020/06/28/ExamBasedonTag/"},{"title":"PowerPoint Resource","text":"此文分享PPT的一些资源包括求是潮全站内训的PPT 求是潮全站内训PPT内训PPT点击此处进行下载 工具篇取色工具drop - mac TakeColor - windows 0.22mb轻量级，很好用，本人极荐 iSlide 排版这是一款全能型的插件，主要的出彩点在于排版色彩和它海量的模板。 下载链接 PA动画专门针对动画的一款PPT插件，但目前69包年，有余裕的自己购买。 下载链接 Think-cell制作图表的一款插件，制作工作汇报年度总结的时候，它可能会帮你很多 下载链接 犸良阿里出品的在线动效制作工具 ispringPPT由于可能到各种地方去运行，可能会遇到环境不兼容无法运行的情况。此插件可将ppt保存为Flash格式，避免此情况。 Aigei音效网站 资源篇OfficePLUS官方模板库 Iconfont矢量图标库阿里巴巴的图标矢量库，海量icon总有你想要的 Color Hunt配色网站 Nippon color日式颜色名，文艺又中二的人可来这找想要的颜色 可能需要科学上网 nipponcolors.com Dribble这个不用说了，我的UI参考都是从这来的 UnsplashBehance 追求设计感","link":"/2019/11/23/ppt-resources/"},{"title":"SFML引入shader/Import shaders(SFML)","text":"既然学了sfml，就试试里面的shader 说实在并不是很清楚shader的GLSL语法是怎么写的，但是既然是类C语言，就不怕读不了源码，于是去google找了相关资料 sf::Shader首先还是sfml对于引入shader的官方文档： In SFML, shaders are represented by the sf::Shader class. It handles both the vertex and fragment shaders: A sf::Shader object is a combination of both (or only one, if the other is not provided). 意思是 sfml 中也有两种shader类即顶点着色器和片元着色器 shader要结合两者进行 12345if (!sf::Shader::isAvailable()){ // 检验shader是否有效 // shaders are not available...} 对sf::Shader的使用如下： 12345678910111213141516171819sf::Shader shader;// load only the vertex shaderif (!shader.loadFromFile(\"vertex_shader.vert\", sf::Shader::Vertex)){ // error...}// load only the fragment shaderif (!shader.loadFromFile(\"fragment_shader.frag\", sf::Shader::Fragment)){ // error...}// load both shadersif (!shader.loadFromFile(\"vertex_shader.vert\", \"fragment_shader.frag\")){ // error...} 而对于shader源文件，文档解释如下： Shaders can also be loaded directly from strings, with the loadFromMemory function. This can be useful if you want to embed the shader source directly into your program. 即shader可由string和文件引入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const std::string vertexShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";const std::string fragmentShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";// load only the vertex shaderif (!shader.loadFromMemory(vertexShader, sf::Shader::Vertex)){ // error...}// load only the fragment shaderif (!shader.loadFromMemory(fragmentShader, sf::Shader::Fragment)){ // error...}// load both shadersif (!shader.loadFromMemory(vertexShader, fragmentShader)){ // error...}const std::string vertexShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";const std::string fragmentShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";// load only the vertex shaderif (!shader.loadFromMemory(vertexShader, sf::Shader::Vertex)){ // error...}// load only the fragment shaderif (!shader.loadFromMemory(fragmentShader, sf::Shader::Fragment)){ // error...}// load both shadersif (!shader.loadFromMemory(vertexShader, fragmentShader)){ // error...} Shader.vert/.frag后缀名其实无所谓，源于文档解释 Shader source is contained in simple text files (like your C++ code). Their extension doesn’t really matter, it can be anything you want, you can even omit it. “.vert” and “.frag” are just examples of possible extensions. 给出水波纹shader的源码： shader.frag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#version 130#水波纹shaderuniform sampler2D currentTexture; // Our render textureuniform sampler2D distortionMapTexture; // Our heat distortion map textureuniform float time; // Time used to scroll the distortion mapuniform float distortionFactor; // Factor used to control severity of the effectuniform float riseFactor; // Factor used to control how fast air risesvoid main(){ vec2 distortionMapCoordinate = gl_TexCoord[0].st; // We use the time value to scroll our distortion texture upwards // Since we enabled texture repeating, OpenGL takes care of // coordinates that lie outside of [0, 1] by discarding // the integer part and keeping the fractional part // Basically performing a \"floating point modulo 1\" // 1.1 = 0.1, 2.4 = 0.4, 10.3 = 0.3 etc. distortionMapCoordinate.t -= time * riseFactor; vec4 distortionMapValue = texture2D(distortionMapTexture, distortionMapCoordinate); // The values are normalized by OpenGL to lie in the range [0, 1] // We want negative offsets too, so we subtract 0.5 and multiply by 2 // We end up with values in the range [-1, 1] vec2 distortionPositionOffset = distortionMapValue.xy; distortionPositionOffset -= vec2(0.5f, 0.5f); distortionPositionOffset *= 2.f; // The factor scales the offset and thus controls the severity distortionPositionOffset *= distortionFactor; // The latter 2 channels of the texture are unused... be creative vec2 distortionUnused = distortionMapValue.zw; // Since we all know that hot air rises and cools, // the effect loses its severity the higher up we get // We use the t (a.k.a. y) texture coordinate of the original texture // to tell us how \"high up\" we are and damp accordingly // Remember, OpenGL 0 is at the bottom distortionPositionOffset *= (1.f - gl_TexCoord[0].t); vec2 distortedTextureCoordinate = gl_TexCoord[0].st + distortionPositionOffset; gl_FragColor = gl_Color * texture2D(currentTexture, distortedTextureCoordinate);} SFML_Shader.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/*! * \\file main.cpp * \\brief apply a heat shader to a sprite (http://www.lucidarme.me/?p=6127) * \\author Philippe Lucidarme (from https://github.com/SFML/SFML/wiki/Source:-HeatHazeShader) * \\version 1.0 * \\date 12/19/2016 */#include &quot;pch.h&quot; // SFML libraries#include &lt;SFML/Graphics.hpp&gt;#include &lt;SFML/System.hpp&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;int main(){ // _____________________ // ::: Create window ::: // Create a window with the same pixel depth as the desktop sf::VideoMode desktopMode = sf::VideoMode::getDesktopMode(); sf::RenderWindow window(sf::VideoMode(desktopMode.width, desktopMode.height, desktopMode.bitsPerPixel), &quot;SFML part 5&quot;);// ,sf::Style::Fullscreen); // Enable vertical sync. (vsync) //window.setVerticalSyncEnabled(true); // ____________________ // ::: Load texture ::: // Create texture from PNG file sf::Texture texture; if (!texture.loadFromFile(&quot;sfml_icon_small.png&quot;)) { std::cerr &lt;&lt; &quot;Error while loading texture&quot; &lt;&lt; std::endl; return -1; } // Enable the smooth filter. The texture appears smoother so that pixels are less noticeable. texture.setSmooth(true); // _______________________________________ // ::: Create sprite and apply texture ::: // Create the sprite and apply the texture sf::Sprite sprite; sprite.setTexture(texture); sf::FloatRect spriteSize = sprite.getGlobalBounds(); // Set origin in the middle of the sprite sprite.setOrigin(spriteSize.width / 2., spriteSize.height / 2.); // _______________ // ::: Shaders ::: // Check if shaders are available if (!sf::Shader::isAvailable()) { std::cerr &lt;&lt; &quot;Shader are not available&quot; &lt;&lt; std::endl; return -1; } // Load shaders sf::Shader shader; if (!shader.loadFromFile(&quot;shader.frag&quot;, sf::Shader::Fragment)) { std::cerr &lt;&lt; &quot;Error while shaders&quot; &lt;&lt; std::endl; return -1; } // ___________________________ // ::: Load distortion map ::: sf::Texture distortionMap; if (!distortionMap.loadFromFile(&quot;distortion_map.png&quot;)) { sf::err() &lt;&lt; &quot;Error while loading distortion map&quot; &lt;&lt; std::endl; return -1; } // It is important to set repeated to true to enable scrolling upwards distortionMap.setRepeated(true); // Setting smooth to true lets us use small maps even on larger images distortionMap.setSmooth(true); // Set texture to the shader shader.setParameter(&quot;currentTexture&quot;, sf::Shader::CurrentTexture); shader.setParameter(&quot;distortionMapTexture&quot;, distortionMap); // Shader parameters float distortionFactor = .05f; float riseFactor = .2f; // _________________ // ::: Main loop ::: sf::Clock timer; while (window.isOpen()) { // Process events sf::Event event; while (window.pollEvent(event)) { // Close the window if a key is pressed or if requested if (event.type == sf::Event::Closed) window.close(); // If a key is pressed if (event.type == sf::Event::KeyPressed) { switch (event.key.code) { // If escape is pressed, close the application case sf::Keyboard::Escape: window.close(); break; // Process the up, down, left and right keys to modify parameters case sf::Keyboard::Up: distortionFactor *= 2.f; break; case sf::Keyboard::Down: distortionFactor /= 2.f; break; case sf::Keyboard::Left: riseFactor *= 2.f; break; case sf::Keyboard::Right: riseFactor /= 2.f; break; default: break; } } } // Set shader parameters shader.setParameter(&quot;time&quot;, timer.getElapsedTime().asSeconds()); shader.setParameter(&quot;distortionFactor&quot;, distortionFactor); shader.setParameter(&quot;riseFactor&quot;, riseFactor); // Clear the window and apply grey background window.clear(sf::Color(127, 127, 127)); // Draw the sprite and apply shader sprite.setPosition(window.getSize().x / 2., window.getSize().y / 2.); sprite.setScale(2, 2); window.draw(sprite, &amp;shader); // Update display and wait for vsync window.display(); } return 0;} 最终效果图 参考链接 sfml官方教程/文档","link":"/2019/11/10/sfml_shader/"},{"title":"Vue.js 组件通讯 REVIEW","text":"组件通讯是vue组件化常用技术，本文对组件通讯的方法进行一个总结。 父组件到子组件prop传值所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。 12345678//childprops:{ msg: String, obj: Object}//parent&lt;ChildNode msg=\"Hello world!\" :obj=\"info\"&gt;&lt;/ChildNode&gt; 非prop的Attribute严格意义来说不算组件通信，但在一些需要被继承的特性出现时，就会变得很有用。这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素（文档原话）。这在开发自定义组件时非常有用。 12345678910111213141516171819//parent&lt;ParentInput type=\"password\" @input=\"handleInput\"&gt;&lt;/ParentInput&gt;//child&lt;template&gt; &lt;label&gt; {{ label }} &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt; &lt;/label&gt;&lt;/template&gt;&lt;script&gt;export default { inheritAttrs:false}&lt;/script&gt; 将原生事件绑定到组件使用v-on=”$listeners”可以将组件的根元素变成完全透明的包裹器，和$attrs类似。 子组件到父组件自定义事件 $emit tips: 始终使用 kebab-case 的事件名 12345//childthis.$emit(\"new-event\",target.value);//parent&lt;ChildNode @new-event=\"handleNewEvent\"&gt;&lt;/ChildNode&gt; 兄弟组件通信共同祖辈搭桥 $parent/$root1234//brother1this.$parent.$on('foo',handle)//brother2this.$parent.$emit('foo') 祖先和后代provide/inject123456789//ancestorprovide(){ return { foo:'foo' }}//descendantinject: ['foo'] 任意两个组件间事件总线（Bus类）创建一个Bus类负责事件派发、监听和处理回调，平时还可以用的方法是new一个Vue实例来充当Bus 123456789101112131415161718192021222324252627class Bus{ constructor(){ /* { eventname:[fn1, fn2] } */ this.callbacks = {} } $on(name, fn) { this.callbacks[name] = this.callbacks[name] || [] this.callbacks[name].push(fn) } $emit(name, args) { this.callbacks[name].forEach(cb=&gt;cb(args)) }}//main.jsVue.prototype.$bus = new Bus()//ORVue.prototype.$bus = new Vue()//child1this.$bus.$on('foo', cb)//child2this.$bus.$emit('foo') vuex状态树附上一张浅显易懂的图 涉及到的API vm.$attrs 2.4.0 新增 类型：{ [key: string]: string } 只读 详细： 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用 inheritAttrs 2.4.0 新增 类型：boolean 默认值：true 详细： 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些 attribute 生效，且可以通过 v-bind 显性的绑定到非根元素上。 注意：这个选项不影响 class 和 style 绑定。 vm.$listeners 2.4.0 新增 类型：{ [key: string]: Function | Array } 只读 详细： 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。","link":"/2020/04/10/vue-communicate/"}],"tags":[{"name":"前端工具","slug":"前端工具","link":"/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"},{"name":"discord","slug":"discord","link":"/tags/discord/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"ComputerGrapics","slug":"ComputerGrapics","link":"/tags/ComputerGrapics/"},{"name":"二维观察","slug":"二维观察","link":"/tags/%E4%BA%8C%E7%BB%B4%E8%A7%82%E5%AF%9F/"},{"name":"裁剪算法","slug":"裁剪算法","link":"/tags/%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95/"},{"name":"project","slug":"project","link":"/tags/project/"},{"name":"PowerPoint","slug":"PowerPoint","link":"/tags/PowerPoint/"},{"name":"sfml","slug":"sfml","link":"/tags/sfml/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"frontend","slug":"frontend","link":"/tags/frontend/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Office","slug":"Office","link":"/categories/Office/"},{"name":"game&graphics","slug":"game-graphics","link":"/categories/game-graphics/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}
{"pages":[],"posts":[{"title":"C#特性Attribute Usage小试","text":"学到System.IO还好，挺简单，到这突然给我来了一巴掌似的。 还是得好好研究下。 在unity当中有[range(0,1)]这样的方法来限制变量范围 Conditional这个预定义特性标记了一个条件方法，其执行依赖于指定的预处理标识符。 123[Conditional( conditionalSymbol)] 需要注意的是此特性需要System.Diagnostics命名空间 1234567891011121314151617#define DEBUGusing System;using System.Diagnostics;public class Myclass{ [Conditional(\"DEBUG\")] public static void Message(string msg) { Console.WriteLine(msg); }}class Test{ public static void Main() { Myclass.Message(\"In Main function.\"); }} 若在上述代码将#define DEBUG去掉，Message就不会编译和执行，可以用来调试时打印过程等 Obsolete这个预定义特性标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。 1234[Obsolete( message, iserror)] 12345[Obsolete(&quot;Don&apos;t use OldMethod, use NewMethod instead&quot;, true)] static void OldMethod() { Console.WriteLine(&quot;It is the old method&quot;); } 然后在Main函数里调用OldMethod便会编译器报错：Don’t use …. ，总之，我目前觉得没啥用，可能重构/项目重写的时候会用到。 构建自定义特性预定义特性 AttributeUsage 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。 123456789101112131415161718192021222324252627282930313233343536[AttributeUsage( validon, AllowMultiple=allowmultiple, Inherited=inherited)]//用法如下[AttributeUsage(AttributeTargets.All)]public class TestAttribute : Attribute{}[TestAttribute]//结构public struct TestStruct { }[TestAttribute]//枚举public enum TestEnum { }[TestAttribute]//类上public class TestClass{ [TestAttribute] public TestClass() { } [TestAttribute]//字段 private string _testField; [TestAttribute]//属性 public string TestProperty { get; set; } [TestAttribute]//方法上 [return: TestAttribute]//定义返回值的写法 public string TestMethod([TestAttribute] string testParam)//参数上 { throw new NotImplementedException(); }} validon 枚举AttributeTargets的值 default 为 AttributeTargets.all AllowMultipie 布尔值：特性是否多用 inherited 布尔值：是否可继承 1234567891011121314151617181920[AttributeUsage(AttributeTargets.Property)] class ValidAttribute : Attribute { public ValidAttribute(int maxLength) { _maxLength = maxLength; } private int _maxLength; protected int MaxLength //这里的get和set和vue里getter setter很像 { get { return _maxLength; } set { _maxLength = value; } } } 自定义一个Attribute类检查字符串长度 写一个实体类使用自定义特性 12345class BaseClass { [Valid(10)] public String Name { get; set; } } 写一个验证类 1234567891011121314151617181920212223class Valid{ public void Validate(object obj) { var t = obj.GetType(); var properties = t.GetProperties(); foreach (var property in properties) { if (!property.IsDefined(typeof(ValidAttribute), false)) continue; var attributes = property.GetCustomAttributes(false); foreach (var attribute in attributes) { var maxLength = (int)attribute.GetType().GetProperty(\"MaxLength\").GetValue(attribute); var propertyValue = property.GetValue(obj) as string; if (propertyValue == null) throw new Exception(\"value is null.\"); if (propertyValue.Length &gt; maxLength) throw new Exception(string.Format(\"属性{0}的值{1}超过了限制长度{2}\", property.Name, propertyValue, maxLength)); } } }} 最后主函数运行 123456789101112131415static void Main(string[] args) { var Account = new Account() { Name = \"Parz1\", Pwd = \"123\" }; try { ValidFunc vf = new ValidFunc(); vf.Validate(Account); Console.WriteLine(vf); } catch (Exception ex) { Console.WriteLine(ex.Message); } Console.ReadLine(); } 测试结果 1属性Name的值Parz112超过了限制长度5 总结学着别人写下来感觉特性配合反射可以做很多事，现在只了解了这么一种写法，其它的以后有时间再跟进。","link":"/2020/01/30/CSharp-Attribute/"},{"title":"OpenGL Config","text":"","link":"/2019/12/20/opengl-config/"},{"title":"Discord下载/使用/修改Hosts","text":"Discord类似国内YY，不过软件不是一个层次。 本文分享discod的下载和修改hosts 本文已废，请使用代理方式，改Hosts方式接下来都不会再有用 首先附上discord的下载地址 Discord 注册地址（需科学上网） 修改host要用到UsbEAm Hosts Editor 本文提供一个链接，自行前往下载： UsbEAm Hosts Editor v3.50 打开效果如下，点击编辑hosts 在文件最后添加如下文本 123456789101112# Discord Start104.16.248.114 dl.discordapp.net104.16.60.37 gateway.discord.gg104.16.11.231 status.discordapp.com104.16.9.231 cdn.discordapp.com104.16.59.5 discordapp.com104.16.250.144 media.discordapp.net104.16.249.144 images-ext-2.discordapp.net104.16.250.144 images-ext-1.discordapp.net151.101.78.214 static-cdn.jtvnw.net# Discord End127.0.0.1 activate.navicat.com127.0.0.1 activate.navicat.com 然后就不用科学上网即可运行discord，注册登录 欢迎来我频道一起玩 https://discord.gg/HyrRPtR 我的Discord标签：parz1#7093","link":"/2020/01/19/discord-usage/"},{"title":"前端各种分辨率测试工具Resolution Test","text":"前端分辨率测试工具，你值得拥有。 Resolution Test 使用方法非常简单，添加到插件里点击它即可。 官网 如果你有更好的方法和工具，欢迎评论或给我发邮件 :)","link":"/2019/11/14/fe-screen/"},{"title":"Cohen-Sutherland 线段裁剪算法","text":"双十一没什么好买的，来写博客了。 裁剪算法：一般情况下用来消除制定区域内或区域外的图形部分的过程叫裁剪。二维裁剪算法有：点/线段/区域/曲线/文字的裁剪，此文介绍Cohen-Sutherland线段裁剪算法。 clear all; n = 100;Xmin = -4; Xmax = 4;Ymin = -3; Ymax = 3; figure; hold on; P1x = rand(1,n)20 - 10;P2x = rand(1,n)20 - 10;P1y = rand(1,n)20 - 10;P2y = rand(1,n)20 - 10;P1code = zeros(n,4);P2code = zeros(n,4); for i = 1:n if P1x(i) &lt; Xmin P1code(i,1) = 1; end if P1x(i) &gt; Xmax P1code(i,2) = 1; end if P1y(i) &lt; Ymin P1code(i,3) = 1; end if P1y(i) &gt; Ymax P1code(i,4) = 1; end if P2x(i) &lt; Xmin P2code(i,1) = 1; end if P2x(i) &gt; Xmax P2code(i,2) = 1; end if P2y(i) &lt; Ymin P2code(i,3) = 1; end if P2y(i) &gt; Ymax P2code(i,4) = 1; end plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],&apos;b-&apos;);endhold off; P_label = zeros(1,n);figure; hold on;for i = 1:n P_or = P1code(i,1:4) | P2code(i,1:4); if sum(P_or) == 0 P_label(i) = 1; plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],’r-‘); end P_and = P1code(i,1:4) &amp; P2code(i,1:4); if sum(P_and) &gt; 0 P_label(i) = 2; plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],’g-‘); endendhold off; figure; hold on;for i = 1:n if P_label(i) == 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 P_or = P1code(i,1:4) | P2code(i,1:4); plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],'g-'); if P_or(1) == 1 Py = P1y(i) + (Xmin-P1x(i))*(P2y(i)-P1y(i))/(P2x(i)-P1x(i)); if P1x(i) &lt; Xmin P1x(i) = Xmin; P1y(i) = Py; elseif P2x(i) &lt; Xmin P2x(i) = Xmin; P2y(i) = Py; end end if P_or(2) == 1 Py = P1y(i) + (Xmax-P1x(i))*(P2y(i)-P1y(i))/(P2x(i)-P1x(i)); if P1x(i) &gt; Xmax P1x(i) = Xmax; P1y(i) = Py; elseif P2x(i) &gt; Xmax P2x(i) = Xmax; P2y(i) = Py; end end if P_or(3) == 1 Px = P1x(i) + (Ymin-P1y(i))/(P2y(i)-P1y(i))*(P2x(i)-P1x(i)); if P1y(i) &lt; Ymin P1x(i) = Px; P1y(i) = Ymin; elseif P2y(i) &lt; Ymin P2x(i) = Px; P2y(i) = Ymin; end end if P_or(4) == 1 Px = P1x(i) + (Ymax-P1y(i))/(P2y(i)-P1y(i))*(P2x(i)-P1x(i)); if P1y(i) &gt; Ymax P1x(i) = Px; P1y(i) = Ymax; elseif P2y(i) &gt; Ymax P2x(i) = Px; P2y(i) = Ymax; end end if P1x(i) &gt;= Xmin &amp; P1x(i) &lt;= Xmax &amp; ... P2x(i) &gt;= Xmin &amp; P2x(i) &lt;= Xmax &amp; ... P1y(i) &gt;= Ymin &amp; P1y(i) &lt;= Ymax &amp; ... P2y(i) &gt;= Ymin &amp; P2y(i) &lt;= Ymax plot([P1x(i),P2x(i)],[P1y(i),P2y(i)],'m-','LineWidth',2); end plot([-4 4 4 -4 -4],[-3 -3 3 3 -3],'b-','LineWidth',2);end","link":"/2019/11/11/grapics-clipping/"},{"title":"PowerPoint Resource","text":"此文分享PPT的一些资源包括求是潮全站内训的PPT 求是潮全站内训PPT内训PPT点击此处进行下载 工具篇取色工具drop - mac TakeColor - windows 0.22mb轻量级，很好用，本人极荐 iSlide 排版这是一款全能型的插件，主要的出彩点在于排版色彩和它海量的模板。 下载链接 PA动画专门针对动画的一款PPT插件，但目前69包年，有余裕的自己购买。 下载链接 Think-cell制作图表的一款插件，制作工作汇报年度总结的时候，它可能会帮你很多 下载链接 犸良阿里出品的在线动效制作工具 ispringPPT由于可能到各种地方去运行，可能会遇到环境不兼容无法运行的情况。此插件可将ppt保存为Flash格式，避免此情况。 Aigei音效网站 资源篇OfficePLUS官方模板库 Iconfont矢量图标库阿里巴巴的图标矢量库，海量icon总有你想要的 Color Hunt配色网站 Nippon color日式颜色名，文艺又中二的人可来这找想要的颜色 可能需要科学上网 nipponcolors.com Dribble这个不用说了，我的UI参考都是从这来的 UnsplashBehance 追求设计感","link":"/2019/11/23/ppt-resources/"},{"title":"SFML引入shader/Import shaders(SFML)","text":"既然学了sfml，就试试里面的shader 说实在并不是很清楚shader的GLSL语法是怎么写的，但是既然是类C语言，就不怕读不了源码，于是去google找了相关资料 sf::Shader首先还是sfml对于引入shader的官方文档： In SFML, shaders are represented by the sf::Shader class. It handles both the vertex and fragment shaders: A sf::Shader object is a combination of both (or only one, if the other is not provided). 意思是 sfml 中也有两种shader类即顶点着色器和片元着色器 shader要结合两者进行 12345if (!sf::Shader::isAvailable()){ // 检验shader是否有效 // shaders are not available...} 对sf::Shader的使用如下： 12345678910111213141516171819sf::Shader shader;// load only the vertex shaderif (!shader.loadFromFile(\"vertex_shader.vert\", sf::Shader::Vertex)){ // error...}// load only the fragment shaderif (!shader.loadFromFile(\"fragment_shader.frag\", sf::Shader::Fragment)){ // error...}// load both shadersif (!shader.loadFromFile(\"vertex_shader.vert\", \"fragment_shader.frag\")){ // error...} 而对于shader源文件，文档解释如下： Shaders can also be loaded directly from strings, with the loadFromMemory function. This can be useful if you want to embed the shader source directly into your program. 即shader可由string和文件引入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const std::string vertexShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";const std::string fragmentShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";// load only the vertex shaderif (!shader.loadFromMemory(vertexShader, sf::Shader::Vertex)){ // error...}// load only the fragment shaderif (!shader.loadFromMemory(fragmentShader, sf::Shader::Fragment)){ // error...}// load both shadersif (!shader.loadFromMemory(vertexShader, fragmentShader)){ // error...}const std::string vertexShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";const std::string fragmentShader = \\ \"void main()\" \\ \"{\" \\ \" ...\" \\ \"}\";// load only the vertex shaderif (!shader.loadFromMemory(vertexShader, sf::Shader::Vertex)){ // error...}// load only the fragment shaderif (!shader.loadFromMemory(fragmentShader, sf::Shader::Fragment)){ // error...}// load both shadersif (!shader.loadFromMemory(vertexShader, fragmentShader)){ // error...} Shader.vert/.frag后缀名其实无所谓，源于文档解释 Shader source is contained in simple text files (like your C++ code). Their extension doesn’t really matter, it can be anything you want, you can even omit it. “.vert” and “.frag” are just examples of possible extensions. 给出水波纹shader的源码： shader.frag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#version 130#水波纹shaderuniform sampler2D currentTexture; // Our render textureuniform sampler2D distortionMapTexture; // Our heat distortion map textureuniform float time; // Time used to scroll the distortion mapuniform float distortionFactor; // Factor used to control severity of the effectuniform float riseFactor; // Factor used to control how fast air risesvoid main(){ vec2 distortionMapCoordinate = gl_TexCoord[0].st; // We use the time value to scroll our distortion texture upwards // Since we enabled texture repeating, OpenGL takes care of // coordinates that lie outside of [0, 1] by discarding // the integer part and keeping the fractional part // Basically performing a \"floating point modulo 1\" // 1.1 = 0.1, 2.4 = 0.4, 10.3 = 0.3 etc. distortionMapCoordinate.t -= time * riseFactor; vec4 distortionMapValue = texture2D(distortionMapTexture, distortionMapCoordinate); // The values are normalized by OpenGL to lie in the range [0, 1] // We want negative offsets too, so we subtract 0.5 and multiply by 2 // We end up with values in the range [-1, 1] vec2 distortionPositionOffset = distortionMapValue.xy; distortionPositionOffset -= vec2(0.5f, 0.5f); distortionPositionOffset *= 2.f; // The factor scales the offset and thus controls the severity distortionPositionOffset *= distortionFactor; // The latter 2 channels of the texture are unused... be creative vec2 distortionUnused = distortionMapValue.zw; // Since we all know that hot air rises and cools, // the effect loses its severity the higher up we get // We use the t (a.k.a. y) texture coordinate of the original texture // to tell us how \"high up\" we are and damp accordingly // Remember, OpenGL 0 is at the bottom distortionPositionOffset *= (1.f - gl_TexCoord[0].t); vec2 distortedTextureCoordinate = gl_TexCoord[0].st + distortionPositionOffset; gl_FragColor = gl_Color * texture2D(currentTexture, distortedTextureCoordinate);} SFML_Shader.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/*! * \\file main.cpp * \\brief apply a heat shader to a sprite (http://www.lucidarme.me/?p=6127) * \\author Philippe Lucidarme (from https://github.com/SFML/SFML/wiki/Source:-HeatHazeShader) * \\version 1.0 * \\date 12/19/2016 */#include &quot;pch.h&quot; // SFML libraries#include &lt;SFML/Graphics.hpp&gt;#include &lt;SFML/System.hpp&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;int main(){ // _____________________ // ::: Create window ::: // Create a window with the same pixel depth as the desktop sf::VideoMode desktopMode = sf::VideoMode::getDesktopMode(); sf::RenderWindow window(sf::VideoMode(desktopMode.width, desktopMode.height, desktopMode.bitsPerPixel), &quot;SFML part 5&quot;);// ,sf::Style::Fullscreen); // Enable vertical sync. (vsync) //window.setVerticalSyncEnabled(true); // ____________________ // ::: Load texture ::: // Create texture from PNG file sf::Texture texture; if (!texture.loadFromFile(&quot;sfml_icon_small.png&quot;)) { std::cerr &lt;&lt; &quot;Error while loading texture&quot; &lt;&lt; std::endl; return -1; } // Enable the smooth filter. The texture appears smoother so that pixels are less noticeable. texture.setSmooth(true); // _______________________________________ // ::: Create sprite and apply texture ::: // Create the sprite and apply the texture sf::Sprite sprite; sprite.setTexture(texture); sf::FloatRect spriteSize = sprite.getGlobalBounds(); // Set origin in the middle of the sprite sprite.setOrigin(spriteSize.width / 2., spriteSize.height / 2.); // _______________ // ::: Shaders ::: // Check if shaders are available if (!sf::Shader::isAvailable()) { std::cerr &lt;&lt; &quot;Shader are not available&quot; &lt;&lt; std::endl; return -1; } // Load shaders sf::Shader shader; if (!shader.loadFromFile(&quot;shader.frag&quot;, sf::Shader::Fragment)) { std::cerr &lt;&lt; &quot;Error while shaders&quot; &lt;&lt; std::endl; return -1; } // ___________________________ // ::: Load distortion map ::: sf::Texture distortionMap; if (!distortionMap.loadFromFile(&quot;distortion_map.png&quot;)) { sf::err() &lt;&lt; &quot;Error while loading distortion map&quot; &lt;&lt; std::endl; return -1; } // It is important to set repeated to true to enable scrolling upwards distortionMap.setRepeated(true); // Setting smooth to true lets us use small maps even on larger images distortionMap.setSmooth(true); // Set texture to the shader shader.setParameter(&quot;currentTexture&quot;, sf::Shader::CurrentTexture); shader.setParameter(&quot;distortionMapTexture&quot;, distortionMap); // Shader parameters float distortionFactor = .05f; float riseFactor = .2f; // _________________ // ::: Main loop ::: sf::Clock timer; while (window.isOpen()) { // Process events sf::Event event; while (window.pollEvent(event)) { // Close the window if a key is pressed or if requested if (event.type == sf::Event::Closed) window.close(); // If a key is pressed if (event.type == sf::Event::KeyPressed) { switch (event.key.code) { // If escape is pressed, close the application case sf::Keyboard::Escape: window.close(); break; // Process the up, down, left and right keys to modify parameters case sf::Keyboard::Up: distortionFactor *= 2.f; break; case sf::Keyboard::Down: distortionFactor /= 2.f; break; case sf::Keyboard::Left: riseFactor *= 2.f; break; case sf::Keyboard::Right: riseFactor /= 2.f; break; default: break; } } } // Set shader parameters shader.setParameter(&quot;time&quot;, timer.getElapsedTime().asSeconds()); shader.setParameter(&quot;distortionFactor&quot;, distortionFactor); shader.setParameter(&quot;riseFactor&quot;, riseFactor); // Clear the window and apply grey background window.clear(sf::Color(127, 127, 127)); // Draw the sprite and apply shader sprite.setPosition(window.getSize().x / 2., window.getSize().y / 2.); sprite.setScale(2, 2); window.draw(sprite, &amp;shader); // Update display and wait for vsync window.display(); } return 0;} 最终效果图 参考链接 sfml官方教程/文档","link":"/2019/11/10/sfml_shader/"}],"tags":[{"name":"graphics","slug":"graphics","link":"/tags/graphics/"},{"name":"discord","slug":"discord","link":"/tags/discord/"},{"name":"前端工具","slug":"前端工具","link":"/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"},{"name":"ComputerGrapics","slug":"ComputerGrapics","link":"/tags/ComputerGrapics/"},{"name":"二维观察","slug":"二维观察","link":"/tags/%E4%BA%8C%E7%BB%B4%E8%A7%82%E5%AF%9F/"},{"name":"裁剪算法","slug":"裁剪算法","link":"/tags/%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95/"},{"name":"PowerPoint","slug":"PowerPoint","link":"/tags/PowerPoint/"},{"name":"sfml","slug":"sfml","link":"/tags/sfml/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Office","slug":"Office","link":"/categories/Office/"},{"name":"game&graphics","slug":"game-graphics","link":"/categories/game-graphics/"}]}